### 1、请描述一下 cookies、 sessionStorage和localstorage区别？
	 相同点：都存储在客户端
	 不同点：	1.cookies大小不超过4k
			webStorage大小可达到5M或更大
			2.有效时间	
				localStorage存储持久数据，关闭浏览器后依然存在
				sessionStorage关闭浏览器后数据自动删除
				cookies在有效时间之内数据会一直存在
			3.交互方式
				cookies与服务器交互。
				webStorage仅在客户端存储
				
### 2、常见的HTTP状态码？
	200: '服务器成功返回请求的数据。',
	201: '新建或修改数据成功。', 
	202: '一个请求已经进入后台排队（异步任务）。', 
	204: '删除数据成功。',
	304：'协商缓存', 
	400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。', 
	401: '用户没有权限（令牌、用户名、密码错误）。', 
	403: '用户得到授权，但是访问是被禁止的。', 
	404: '发出的请求针对的是不存在的记录，服务器没有进行操作。', 
	406: '请求的格式不可得。', 
	410: '请求的资源被永久删除，且不会再得到的。', 
	422: '当创建一个对象时，发生一个验证错误。', 
	500: '服务器发生错误，请检查服务器。', 
	502: '网关错误。', 
	503: '服务不可用，服务器暂时过载或维护。', 
	504: '网关超时。'
### 3、bootstrap响应式实现的原理?
	Bootstrap响应式布局是利用其栅格系统，对于不同的屏幕采用不同的类属性。
	网格系统的实现原理，是通过定义容器大小，平分12份(也有平分成24份或32份，
	但12份是最常见的)，再调整内外边距，最后结合媒体查询，就制作出了强大的
	响应式网格系统。
### 4、如何优化页面，加快页面的加载速度
	1、优化DNS查询
 		+ 减少域名：尽量把所有的资源放在一个域名下。一个域名同时可以发4（IE8）或8个请求（Chrome）。
	请求文件少，用1个域名，文件多用多个域名。与3权衡。
	2、优化TCP协议
		+ CP连接复用，使用keep-alive：连接回复加上请求头：keep-alive。第一次请求不断开，第二次请求复用。
		+ 使用http 2.0版本：多路复用，连接复用率会更高
	3、优化发送HTTP请求
		+ 合并JS或CSS文件
		+ inline image：使用data:url scheme来内连图片
		+ 减小cookie体积，每个请求都会附带cookie，所以不要滥用cookie。
		+ 合理使用CasheControl代替发送HTTP请求
		+ 同时发送多个请求（浏览器自带）IE8可以同时请求下载4个的css文件，Chrome可以同时请求下载8个 。
	4、优化接受响应
		+ 设置Etags：浏览器重复与请求服务器一样的文件，ETag响应304。
		+ Gzip压缩大文件 使用macos gzip，npm server gzip gzip 文件名
		  其响应头为Content-Encodinging：gzip，先压缩接收到再解压缩。缺点：耗费浏览器CPU，权衡
	5、优化DOCTYPE 
		不能不写
	6、优化CSS,JS请求
		使用CDN：用CDN请求静态资源同时可以增大同时下载数量，内容分发网络（CDN）可以使请求总时间降低，也可以减少cookie
		CSS放在head里：使其尽早下载，因为chrome需要下载完所有的css后才渲染页面
		JS放在body里的最后：尽早显示整个页面，获取节点。
	7、使用懒加载
		组件懒加载。
		const xxx =()=>import('./components/xxx.vue')
		路由懒加载。
	8、优化用户体验
	9、减少监听器
		 <body>
		        <ul>
		            <li>1</li>
		            <li>2</li>
		            <li>3</li>
		            <li>4</li>
		        </ul>
		        <script>
		            let liList = document.querySelectorAll('li')
		
		            // liList[0].onclick = ()=>console.log(1)
		            // liList[1].onclick = ()=>console.log(2)
		            // liList[2].onclick = ()=>console.log(3)
		            // liList[3].onclick = ()=>console.log(4)
		            //法一：监听太多
		
		            let ul = document.querySelector('ul')
		
		            ul.onclick = (e) => {
		                if (e.target.tagName === 'LI') {
		                    console.log(e.target.innerText)
		
		                }
		            }//法二：减少监听，采用事件委托
		        </script>
		    </body>
	10、优化图片大小
	11、减少或者合并DOM，使用虚拟DOM
	12、对大量数据计算使用缓存
		// data.length === 100000
		   for(var i = 0;i < data.length;i++){
		     // do something...
		   }
		   //上面的代码没有下面的好
		   for(var i = 0,len = data.length;i < len;i++){
		     // do something...
		   }
	13、使用setTimeout降低调用接口频率
###	5、Vue的请求数据方式
	1、vue-resoruce
	2、axios
	3、fetch-jsonp
### 6、Http与Https的区别
	1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
	
	2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
	
	3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
	
	4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
### 7、Vuex的属性
	1、state => 基本数据 
	2、getters => 从基本数据派生的数据 
	3、mutations => 提交更改数据的方法，同步！ 
	4、actions => 像一个装饰器，包裹mutations，使之可以异步。 
	5、modules => 模块化Vuex
### 8、Vue双向绑定原理
	Object.defineProperty()
### 9、h5新标签
	1、Header：页眉
	2、nav：标记导航
	3、article：文章标记标签
	4、section：区块定义标签
	5、定义侧栏标签
	6、footer：页脚
	![基本布局.png](https://img-blog.csdnimg.cn/20190703200418732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FROTcyNjE4NDc4,size_16,color_FFFFFF,t_70)
### 10、Vue全家桶
	1、vue-cli：是vue官方提供的快速搭建项目的工具
	2、vuex：是vue提供的状态管理工具
	3、vue-router:是vue生态里面的路由工具，采用路由能轻松实现单页面程序
	4、axios(ajax)
### 11、MVVM思想
	MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，
	View负责显示，两者做到了最大限度的分离。把Model和View关联起来的就是ViewModel。ViewModel负责把Model
	的数据同步到View显示出来，还负责把View的修改同步回Model。ViewModel如何编写？需要用JavaScript编写一
	个通用的ViewModel，这样，就可以复用整个MVVM模型了。
### 12、合并数组
	//concat
	let arr1 = [1,2,30];
	let arr2 = ['a','b','c'];
	let arr3 = arr1.concat(arr2);
	console.log(arr3);
	//apply()
	let arr1 = [1,2,30];
	let arr2 = ['a','b','c'];
	arr1.push.apply(arr1,arr2);
	console.log(arr1)
### 13、垂直居中
	.box1{
		position: absolute;
		width: 100px;
		height: 100px;
		background-color: red;
		top: 50%;
		/* left: 50%; */
		margin-top: -50px;
		/* margin-left: -50px; */
	}
### 14、call,apply,bind的区别？
	1、Function.prototype.call()
		函数实例的call方法，可以指定该函数内部this
		的指向（即函数执行时所在的作用域），然后在所
		指定的作用域中，调用该函数。并且会立即执行该函数。
	2、Function.prototype.apply()
		apply方法的作用与call方法类似，也是改变this指向
		函数执行时所在的作用域），然后在指定的作用域中，
		调用该函数。同时也会立即执行该函数。唯一的区别就是，
		它接收一个数组作为函数执行时的参数。
		function huan(a,b){
			console.log(a+b)
		}
		huan.call(null,2,1);
		huan.apply(null,[1,3]);
		
		***找出数组中的最大值
		var s = [1,2,3,4,5,6,7,8,9];
		console.log(Math.max.apply(null,s));
		console.log(Math.max.call(null,2, 4, 5, 7, 8, 10));
	3、Function.prototype.bind()
		bind方法用于指定函数内部的this指向（执行时所在的作用域），
		然后返回一个新函数。bind方法并非立即执行一个函数。